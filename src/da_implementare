devo poter definire funzioni su spazio reale e avere indietro le funzioni trasformate nello spazio reciproco e viceversa

voglio f_p(r):grid -> grid_function (definibile sia nello spazio reale che nello spazio reciproco)
f distanza di r da un punto p della griglia (risolvere problema della distanza = 0?)

implementare:

Classi
  ok  cell
  ok  grid (con centratura in 0 o MIC, spazio di punti)
  ok  grid_space (ha grid su sp reale + grid su sp reciproco)
  ok  grid_func_base (funzioni su grid)
  ok  grid_func su sp reale (prende grid_space come spazio)
  ok  grid_func_rec su sp reciproco (prende grid_space come spazio)

- MIC sia su spazio reale che su spazio reciproco (per ora normale,mic)

- su Grid:
    ok a) invgrid (ritorna grid su sp reciproco)
    ok b) metodo "funzione distanza"(p (punto della griglia (default: coordinate crystal)) crea new grid_func_base f(z)=dist(z,p) (cartesian)
    ok b) metodo "funzione quadrato della distanza"(p (punto della griglia (default: coordinate crystal)) crea new grid_func_base f(z)=<z,p> (cartesian coordinates)
    c) funzione gaussiana centrata su punto p (parametri: p e sigma)

- su Grid_func_base:
    ok a) metodo "integral" per avere il valore della somma di f sui punti della grid
    ok b) metodo self.dotFunc(f) -> self(x)=self(x)*f(x)
    ok c) metodo self.sumFunc(f) -> self(x)=self(x)+f(x)
    ok d) metodo self.dotCnst(c) -> self(x)=self(x)*c
    ok e) metodo self.sumCnst(c) -> self(x)=self(x)+c
    ok f) metodo self.exponentiationCnst(c) -> self(x)=self(x)**c
    ok g) metodo self.linearComb(f,a,b) -> self(x)=a*self(x)+b*f(x) combinazione lineare di funzioni
    ok h) metodo self.exp -> self(x)=exp(self(x))

devo definire grid_func su real e grid_func_rec su reciprocal di grid_space (unico "spazio" e' grid_space)

su grid_func_rec:
    ok .ifft() -> new grid_func

su grid_func:
    ok .fft() -> new grid_func_rec
    .apply_trasf(grid_func_rec,R,R,R) -> new grid_func
        input:
            self=f(z) su spazio reale, a, b e c (in R), u(q) su spazio reciproco
        output:
            g(z)=f(z)^a, h(z)=f(z)^b
            H(q)=fft(h)
            K(q)=H(q)*u(q) (check)

            ottengo k(z)=ifft(K)*g(z)*c

    k.Int per avere Integrale su grid (somma valori di k su punti grid)

